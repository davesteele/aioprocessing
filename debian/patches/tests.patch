--- /dev/null
+++ b/tests/_base_test.py
@@ -0,0 +1,35 @@
+import asyncio
+import unittest
+import multiprocessing
+
+
+class BaseTest(unittest.TestCase):
+    def setUp(self):
+        self.loop = asyncio.get_event_loop()
+
+    def assertReturnsIfImplemented(self, value, func, *args):
+        try:
+            res = func(*args)
+        except NotImplementedError:
+            pass
+        else:
+            return self.assertEqual(value, res)
+
+
+class _GenMixin:
+    initargs = ()
+    args = ()
+
+    def test_loop(self):
+        loop = asyncio.new_event_loop()
+        getattr(self.inst, self.meth)(*self.args, loop=loop)
+        self._after()
+
+    @unittest.skipIf(not hasattr(multiprocessing, 'get_context'),
+                     "Not supported in this version of Python")
+    def test_ctx(self):
+        ctx = multiprocessing.get_context("spawn")
+        self.Obj(*self.initargs, context=ctx)
+
+    def _after(self):
+        pass
--- /dev/null
+++ b/tests/connection_tests.py
@@ -0,0 +1,127 @@
+import asyncio
+import unittest
+import multiprocessing
+from multiprocessing import Process
+from array import array
+
+import aioprocessing
+from aioprocessing.connection import AioConnection, AioListener, AioClient
+
+from ._base_test import BaseTest
+
+
+def conn_send(conn, val):
+    conn.send(val)
+
+
+def client_sendback(event, address, authkey):
+    event.wait()
+    conn = multiprocessing.connection.Client(address, authkey=authkey)
+    got = conn.recv()
+    conn.send(got+got)
+    conn.close()
+
+
+def listener_sendback(event, address, authkey):
+        listener = multiprocessing.connection.Listener(address,
+                                                       authkey=authkey)
+        event.set()
+        conn = listener.accept()
+        inval = conn.recv()
+        conn.send_bytes(array('i', [inval, inval+1, inval+2, inval+3]))
+        conn.close()
+
+
+class PipeTest(BaseTest):
+    def test_pipe(self):
+        conn1, conn2 = aioprocessing.AioPipe()
+        val = 25
+        p = Process(target=conn_send, args=(conn1, val))
+        p.start()
+
+        @asyncio.coroutine
+        def conn_recv():
+            out = yield from conn2.coro_recv()
+            self.assertEqual(out, val)
+
+        self.loop.run_until_complete(conn_recv())
+
+
+class ListenerTest(BaseTest):
+    def test_listener(self):
+        address = ('localhost', 8999)
+        authkey = b'abcdefg'
+        event = multiprocessing.Event()
+        p = Process(target=client_sendback, args=(event, address, authkey))
+        p.start()
+        listener = AioListener(address, authkey=authkey)
+        try:
+            event.set()
+            conn = listener.accept()
+            self.assertIsInstance(conn, AioConnection)
+            conn.send("")
+            conn.close()
+            event.clear()
+            p.join()
+            p = Process(target=client_sendback, args=(event, address, authkey))
+            p.start()
+
+            def conn_accept():
+                fut = listener.coro_accept()
+                event.set()
+                conn = yield from fut
+                self.assertIsInstance(conn, AioConnection)
+                yield from conn.coro_send("hi there")
+                back = yield from conn.coro_recv()
+                self.assertEqual(back, "hi therehi there")
+                conn.close()
+
+            self.loop.run_until_complete(conn_accept())
+            p.join()
+        finally:
+            listener.close()
+
+    def test_client(self):
+        address = ('localhost', 8999)
+        authkey = b'abcdefg'
+        event = multiprocessing.Event()
+        p = Process(target=listener_sendback, args=(event, address, authkey))
+        p.start()
+        event.wait()
+        conn = AioClient(address, authkey=authkey)
+        self.assertIsInstance(conn, AioConnection)
+
+        def do_work():
+            yield from conn.coro_send(25)
+            arr = array('i', [0, 0, 0, 0])
+            yield from conn.coro_recv_bytes_into(arr)
+            self.assertEqual(arr, array('i', [25, 26, 27, 28]))
+            conn.close()
+
+        self.loop.run_until_complete(do_work())
+        p.join()
+
+    def test_listener_ctxmgr(self):
+        address = ('localhost', 8999)
+        authkey = b'abcdefg'
+        with AioListener(address, authkey=authkey) as listener:
+            self.assertIsInstance(listener, AioListener)
+        self.assertRaises(OSError, listener.accept)
+
+    def test_client_ctxmgr(self):
+        address = ('localhost', 8999)
+        authkey = b'abcdefg'
+        event = multiprocessing.Event()
+        p = Process(target=listener_sendback, args=(event, address, authkey))
+        p.daemon = True
+        p.start()
+        event.wait()
+        with AioClient(address, authkey=authkey) as conn:
+            self.assertIsInstance(conn, AioConnection)
+        self.assertRaises(OSError, conn.send, "hi")
+        p.terminate()
+        p.join()
+
+
+if __name__ == "__main__":
+    unittest.main()
--- /dev/null
+++ b/tests/lock_tests.py
@@ -0,0 +1,420 @@
+import multiprocessing
+import sys
+import time
+import asyncio
+import unittest
+import traceback
+import aioprocessing
+from multiprocessing import Process, Event, Queue, get_all_start_methods
+try:
+    from multiprocessing import get_context
+except ImportError:
+    def get_context(param):
+        pass
+
+from ._base_test import BaseTest, _GenMixin
+
+MANAGER_TYPE = 1
+STANDARD_TYPE = 2
+
+
+def get_value(self):
+    try:
+        return self.get_value()
+    except AttributeError:
+        try:
+            return self._Semaphore__value
+        except AttributeError:
+            try:
+                return self._value
+            except AttributeError:
+                raise NotImplementedError
+
+
+def do_lock_acquire(lock, e):
+    lock.acquire()
+    e.set()
+    time.sleep(2)
+    lock.release()
+
+
+def sync_lock(lock, event, event2, queue):
+    event2.wait()
+    queue.put(lock.acquire(False))
+    event.set()
+    lock.acquire()
+    lock.release()
+
+
+class GenAioLockTest(BaseTest, _GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.Obj = aioprocessing.AioLock
+        self.inst = self.Obj()
+        self.meth = 'coro_acquire'
+
+
+class GenAioManagerLockTest(GenAioLockTest):
+    def setUp(self):
+        super().setUp()
+        self.manager = aioprocessing.AioManager()
+        self.Obj = self.manager.AioLock
+        self.inst = self.Obj()
+
+    @unittest.skipIf(not hasattr(multiprocessing, 'get_context'),
+                     "No get_context method")
+    def test_ctx(self): pass
+
+
+class GenAioRLockTest(BaseTest, _GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.Obj = aioprocessing.AioRLock
+        self.inst = self.Obj()
+        self.meth = 'coro_acquire'
+
+
+class GenAioConditionTest(BaseTest, _GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.Obj = aioprocessing.AioCondition
+        self.inst = self.Obj()
+        self.meth = 'coro_acquire'
+
+
+class GenAioSemaphoreTest(BaseTest, _GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.Obj = aioprocessing.AioSemaphore
+        self.inst = self.Obj()
+        self.meth = 'coro_acquire'
+
+
+class GenAioEventTest(BaseTest, _GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.Obj = aioprocessing.AioEvent
+        self.inst = self.Obj()
+        self.meth = 'coro_wait'
+
+    def _after(self):
+        self.inst.set()
+
+
+class GenAioBarrierTest(BaseTest, _GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.Obj = aioprocessing.AioBarrier
+        self.inst = self.Obj(1)
+        self.initargs = (1,)
+        self.meth = 'coro_wait'
+
+
+class LoopLockTest(BaseTest):
+    def setUp(self):
+        pass
+
+    def test_lock_with_loop(self):
+        loop = asyncio.new_event_loop()
+        lock = aioprocessing.AioLock()
+
+        @asyncio.coroutine
+        def do_async_lock():
+            yield from lock.coro_acquire(loop=loop)
+
+        loop.run_until_complete(do_async_lock())
+
+
+class LockTest(BaseTest):
+    def setUp(self):
+        super().setUp()
+        self.type_ = STANDARD_TYPE
+        self.lock = aioprocessing.AioLock()
+
+    def test_lock(self):
+        self.assertEqual(True, self.lock.acquire())
+        self.assertEqual(False, self.lock.acquire(False))
+        self.assertEqual(None, self.lock.release())
+
+    def test_lock_async(self):
+        @asyncio.coroutine
+        def do_async_lock():
+            self.assertEqual(True, (yield from self.lock.coro_acquire()))
+            self.assertEqual(None, self.lock.release())
+
+        self.loop.run_until_complete(do_async_lock())
+
+    def test_lock_cm(self):
+        event = Event()
+        event2 = Event()
+        q = Queue()
+
+        @asyncio.coroutine
+        def with_lock():
+            with (yield from self.lock):
+                event2.set()
+                asyncio.sleep(1)
+                event.wait()
+
+        p = Process(target=sync_lock, args=(self.lock, event, event2, q))
+        p.start()
+        self.loop.run_until_complete(with_lock())
+        p.join()
+        self.assertFalse(q.get())
+
+    def test_lock_multiproc(self):
+        e = Event()
+
+        @asyncio.coroutine
+        def do_async_lock():
+            self.assertEqual(False, (yield from self.lock.coro_acquire(False)))
+            self.assertEqual(True,
+                             (yield from self.lock.coro_acquire(timeout=4)))
+
+        p = Process(target=do_lock_acquire, args=(self.lock, e))
+        p.start()
+        e.wait()
+        self.loop.run_until_complete(do_async_lock())
+
+
+class LockManagerTest(LockTest):
+    def setUp(self):
+        super().setUp()
+        self.type_ = MANAGER_TYPE
+        self.manager = aioprocessing.AioManager()
+        self.lock = self.manager.AioLock()
+
+    def tearDown(self):
+        super().tearDown()
+        self.manager.shutdown()
+        self.manager.join()
+
+
+class RLockTest(LockTest):
+    def setUp(self):
+        super().setUp()
+        self.lock = aioprocessing.AioRLock()
+
+    def test_lock(self):
+        self.assertEqual(True, self.lock.acquire())
+        self.assertEqual(True, self.lock.acquire(False))
+        self.assertEqual(None, self.lock.release())
+
+
+class RLockManagerTest(RLockTest):
+    def setUp(self):
+        super().setUp()
+        self.type_ = MANAGER_TYPE
+        self.manager = aioprocessing.AioManager()
+        self.lock = self.manager.AioRLock()
+
+    def tearDown(self):
+        super().tearDown()
+        self.manager.shutdown()
+        self.manager.join()
+
+
+def mix_release(lock, q):
+    try:
+        try:
+            lock.release()
+        except (ValueError, AssertionError):
+            pass
+        else:
+            q.put("Didn't get excepted AssertionError")
+        lock.acquire()
+        lock.release()
+        q.put(True)
+    except Exception:
+        exc = traceback.format_exception(*sys.exc_info())
+        q.put(exc)
+
+
+class LockMixingTest(BaseTest):
+    def setUp(self):
+        super().setUp()
+        self.lock = aioprocessing.AioRLock()
+
+    def test_sync_lock(self):
+        self.lock.acquire()
+        self.lock.release()
+
+    def test_mix_async_to_sync(self):
+        @asyncio.coroutine
+        def do_acquire():
+            yield from self.lock.coro_acquire()
+
+        self.loop.run_until_complete(do_acquire())
+
+        self.lock.release()
+
+    def test_mix_with_procs(self):
+        @asyncio.coroutine
+        def do_acquire():
+            yield from self.lock.coro_acquire()
+        q = Queue()
+        p = Process(target=mix_release, args=(self.lock, q))
+        self.loop.run_until_complete(do_acquire())
+        p.start()
+        self.lock.release()
+        out = q.get(timeout=5)
+        p.join()
+        self.assertTrue(isinstance(out, bool))
+
+
+class SpawnLockMixingTest(LockMixingTest):
+    def setUp(self):
+        super().setUp()
+        context = get_context('spawn')
+        self.lock = aioprocessing.AioLock(context=context)
+
+
+if 'forkserver' in get_all_start_methods():
+    class ForkServerLockMixingTest(LockMixingTest):
+        def setUp(self):
+            super().setUp()
+            context = get_context('forkserver')
+            self.lock = aioprocessing.AioLock(context=context)
+
+
+class SemaphoreTest(BaseTest):
+    def setUp(self):
+        super().setUp()
+        self.sem = aioprocessing.AioSemaphore(2)
+
+    def _test_semaphore(self, sem):
+        self.assertReturnsIfImplemented(2, get_value, sem)
+        self.assertEqual(True, sem.acquire())
+        self.assertReturnsIfImplemented(1, get_value, sem)
+
+        @asyncio.coroutine
+        def sem_acquire():
+            self.assertEqual(True, (yield from sem.coro_acquire()))
+        self.loop.run_until_complete(sem_acquire())
+        self.assertReturnsIfImplemented(0, get_value, sem)
+        self.assertEqual(False, sem.acquire(False))
+        self.assertReturnsIfImplemented(0, get_value, sem)
+        self.assertEqual(None, sem.release())
+        self.assertReturnsIfImplemented(1, get_value, sem)
+        self.assertEqual(None, sem.release())
+        self.assertReturnsIfImplemented(2, get_value, sem)
+
+    def test_semaphore(self):
+        sem = self.sem
+        self._test_semaphore(sem)
+        self.assertEqual(None, sem.release())
+        self.assertReturnsIfImplemented(3, get_value, sem)
+        self.assertEqual(None, sem.release())
+        self.assertReturnsIfImplemented(4, get_value, sem)
+
+
+class BoundedSemaphoreTest(SemaphoreTest):
+    def setUp(self):
+        super().setUp()
+        self.sem = aioprocessing.AioBoundedSemaphore(2)
+
+    def test_semaphore(self):
+        self._test_semaphore(self.sem)
+
+
+def barrier_wait(barrier, event):
+    event.set()
+    barrier.wait()
+
+
+class BarrierTest(BaseTest):
+    def setUp(self):
+        super().setUp()
+        self.barrier = aioprocessing.AioBarrier(2)
+
+    def _wait_barrier(self):
+        self.barrier.wait()
+
+#     def test_barrier(self):
+#         fut = None
+# 
+#         @asyncio.coroutine
+#         def wait_barrier_async():
+#             yield from self.barrier.coro_wait()
+# 
+#         def wait_barrier():
+#             nonlocal fut
+#             fut = asyncio.ensure_future(wait_barrier_async())
+#             yield from asyncio.sleep(.5)
+#             self.assertEqual(1, self.barrier.n_waiting)
+#             self.barrier.wait()
+# 
+#         # t = threading.Thread(target=self._wait_barrier)
+#         # t.start()
+#         self.loop.run_until_complete(wait_barrier())
+#         self.loop.run_until_complete(fut)
+
+    def test_barrier_multiproc(self):
+        event = Event()
+        p = Process(target=barrier_wait, args=(self.barrier, event))
+        p.start()
+
+        @asyncio.coroutine
+        def wait_barrier():
+            event.wait()
+            yield from asyncio.sleep(.2)
+            self.assertEqual(1, self.barrier.n_waiting)
+            yield from self.barrier.coro_wait()
+        self.loop.run_until_complete(wait_barrier())
+        p.join()
+
+
+def set_event(event):
+    event.set()
+
+
+class EventTest(BaseTest):
+    def setUp(self):
+        super().setUp()
+        self.event = aioprocessing.AioEvent()
+
+    def test_event(self):
+        p = Process(target=set_event, args=(self.event,))
+
+        @asyncio.coroutine
+        def wait_event():
+            yield from self.event.coro_wait()
+
+        p.start()
+        self.loop.run_until_complete(wait_event())
+        p.join()
+
+
+def cond_notify(cond, event):
+    time.sleep(2)
+    event.set()
+    cond.acquire()
+    cond.notify_all()
+    cond.release()
+
+
+class ConditionTest(BaseTest):
+    def setUp(self):
+        super().setUp()
+        self.cond = aioprocessing.AioCondition()
+
+    def test_cond(self):
+        event = Event()
+
+        def pred():
+            return event.is_set()
+
+        @asyncio.coroutine
+        def wait_for_pred():
+            yield from self.cond.coro_acquire()
+            yield from self.cond.coro_wait_for(pred)
+            self.cond.release()
+
+        p = Process(target=cond_notify, args=(self.cond, event))
+        p.start()
+        self.loop.run_until_complete(wait_for_pred())
+        p.join()
+
+
+if __name__ == "__main__":
+    unittest.main()
--- /dev/null
+++ b/tests/pickle_test.py
@@ -0,0 +1,16 @@
+import pickle
+import unittest
+from aioprocessing.executor import _ExecutorMixin
+
+
+class PickleTest(unittest.TestCase):
+    def test_pickle_queue(self):
+        q = _ExecutorMixin()
+        q.test = "abc"
+        pickled = pickle.dumps(q)
+        unpickled = pickle.loads(pickled)
+        self.assertEqual(q.test, unpickled.test)
+
+
+if __name__ == "__main__":
+    unittest.main()
--- /dev/null
+++ b/tests/pool_test.py
@@ -0,0 +1,83 @@
+import asyncio
+import aioprocessing
+
+import os, sys
+sys.path.append(os.path.dirname(__file__))
+
+
+from _base_test import BaseTest, _GenMixin
+
+
+def work_func(a, b):
+    c = a * b
+    return c
+
+
+def map_func(z):
+    return z * 3
+
+
+def starmap(func, it):
+    return map(func, *zip(*it))
+
+
+class GenAioPoolTest(BaseTest, _GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.Obj = aioprocessing.AioPool
+        self.inst = self.Obj(1)
+        self.initargs = (1,)
+        self.meth = 'coro_map'
+        self.args = (map_func, [1, 2, 3],)
+
+
+class PoolTest(BaseTest):
+    def setUp(self):
+        super().setUp()
+        self.pool = aioprocessing.AioPool()
+
+    def tearDown(self):
+        super().tearDown()
+        self.pool.close()
+        self.pool.join()
+
+    def test_ctx_mgr(self):
+        with aioprocessing.AioPool() as pool:
+            self.assertIsInstance(pool, aioprocessing.pool.AioPool)
+        self.assertRaises(ValueError, pool.map, map_func, [1])
+
+    def test_coro_apply(self):
+        @asyncio.coroutine
+        def do_apply():
+            out = yield from self.pool.coro_apply(work_func, args=(2, 3))
+            self.assertEqual(out, 6)
+
+        self.loop.run_until_complete(do_apply())
+
+    def test_coro_map(self):
+        it = list(range(5))
+
+        @asyncio.coroutine
+        def do_map():
+            out = yield from self.pool.coro_map(map_func, it)
+            self.assertEqual(out, list(map(map_func, it)))
+
+        self.loop.run_until_complete(do_map())
+
+    def test_coro_starmap(self):
+        it = list(zip(range(5), range(5, 10)))
+
+        @asyncio.coroutine
+        def do_starmap():
+            out = yield from self.pool.coro_starmap(work_func, it)
+            self.assertEqual(out, list(starmap(work_func, it)))
+
+        self.loop.run_until_complete(do_starmap())
+
+    def test_coro_join(self):
+        @asyncio.coroutine
+        def do_join():
+            yield from self.pool.coro_join()
+
+        self.pool.close()
+        self.loop.run_until_complete(do_join())
--- /dev/null
+++ b/tests/process_test.py
@@ -0,0 +1,44 @@
+import asyncio
+import unittest
+import multiprocessing
+
+import aioprocessing
+
+import os, sys
+sys.path.append(os.path.dirname(__file__))
+
+from _base_test import BaseTest, _GenMixin
+
+
+def f(q, a, b):
+    q.put((a, b))
+
+
+def dummy():
+    pass
+
+
+class GenAioProcessTest(BaseTest, _GenMixin):
+    def setUp(self):
+        self.Obj = aioprocessing.AioProcess
+        self.inst = self.Obj(target=dummy)
+        self.meth = 'coro_join'
+
+
+class ProcessTest(BaseTest):
+    def test_pickle_queue(self):
+        t = ("a", "b")
+        q = multiprocessing.Queue()
+        p = aioprocessing.AioProcess(target=f, args=(q,) + t)
+        p.start()
+
+        @asyncio.coroutine
+        def join():
+            yield from p.coro_join()
+
+        self.loop.run_until_complete(join())
+        self.assertEqual(q.get(), t)
+
+
+if __name__ == "__main__":
+    unittest.main()
--- /dev/null
+++ b/tests/queue_test.py
@@ -0,0 +1,141 @@
+import asyncio
+import unittest
+import aioprocessing
+from multiprocessing import Process, Event
+from concurrent.futures import ProcessPoolExecutor
+
+import os, sys
+sys.path.append(os.path.dirname(__file__))
+from _base_test import BaseTest, _GenMixin
+
+
+def queue_put(q, val):
+    val = q.put(val)
+    return val
+
+
+def queue_get(q, e):
+    val = q.get()
+    e.set()
+    q.put(val)
+
+
+class GenQueueMixin(_GenMixin):
+    def setUp(self):
+        super().setUp()
+        self.inst = self.Obj()
+        self.meth = 'coro_get'
+
+    def _after(self):
+        self.inst.put(1)
+
+
+class GenAioQueueTest(GenQueueMixin, BaseTest):
+    def setUp(self):
+        self.Obj = aioprocessing.AioQueue
+        super().setUp()
+
+
+class GenAioSimpleQueueTest(GenQueueMixin, BaseTest):
+    def setUp(self):
+        self.Obj = aioprocessing.AioSimpleQueue
+        super().setUp()
+
+
+class GenAioJoinableQueueTest(GenQueueMixin, BaseTest):
+    def setUp(self):
+        self.Obj = aioprocessing.AioJoinableQueue
+        super().setUp()
+
+
+class QueueTest(BaseTest):
+    def test_blocking_put(self):
+        q = aioprocessing.AioQueue()
+
+        @asyncio.coroutine
+        def queue_put():
+            yield from q.coro_put(1)
+
+        self.loop.run_until_complete(queue_put())
+        self.assertEqual(q.get(), 1)
+
+    def test_put_get(self):
+        q = aioprocessing.AioQueue()
+        val = 1
+        p = Process(target=queue_put, args=(q, val))
+
+        @asyncio.coroutine
+        def queue_get():
+            ret = yield from q.coro_get()
+            self.assertEqual(ret, val)
+
+        p.start()
+        self.loop.run_until_complete(queue_get())
+        p.join()
+
+    def test_get_put(self):
+        q = aioprocessing.AioQueue()
+        e = Event()
+        val = 2
+
+        @asyncio.coroutine
+        def queue_put():
+            yield from q.coro_put(val)
+
+        p = Process(target=queue_get, args=(q, e))
+        p.start()
+        self.loop.run_until_complete(queue_put())
+        e.wait()
+        out = q.get()
+        p.join()
+        self.assertEqual(out, val)
+
+    def test_simple_queue(self):
+        q = aioprocessing.AioSimpleQueue()
+        val = 8
+
+        @asyncio.coroutine
+        def queue_put():
+            yield from q.coro_put(val)
+
+        self.loop.run_until_complete(queue_put())
+        out = q.get()
+        self.assertEqual(val, out)
+
+
+class ManagerQueueTest(BaseTest):
+    def test_executor(self):
+        m = aioprocessing.AioManager()
+        q = m.AioQueue()
+        p = ProcessPoolExecutor(max_workers=1)
+        val = 4
+
+        def submit():
+            yield p.submit(queue_put, q, val)
+        next(submit())
+
+        @asyncio.coroutine
+        def queue_get():
+            out = yield from q.coro_get()
+            self.assertEqual(out, val)
+            yield from q.coro_put(5)
+
+        self.loop.run_until_complete(queue_get())
+        returned = q.get()
+        self.assertEqual(returned, 5)
+        p.shutdown()
+
+
+class JoinableQueueTest(BaseTest):
+    def test_join_empty_queue(self):
+        q = aioprocessing.AioJoinableQueue()
+
+        @asyncio.coroutine
+        def join():
+            yield from q.coro_join()
+
+        self.loop.run_until_complete(join())
+
+
+if __name__ == "__main__":
+    unittest.main()
